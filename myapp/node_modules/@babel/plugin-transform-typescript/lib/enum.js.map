{"version":3,"names":["_core","require","_assert","_helperAnnotateAsPure","_helperSkipTransparentExpressionWrappers","ENUMS","WeakMap","buildEnumWrapper","template","expression","transpileEnum","path","t","node","parentPath","declare","remove","name","id","fill","data","isPure","enumFill","type","isGlobal","isProgram","parent","isSeen","seen","init","objectExpression","logicalExpression","cloneNode","ID","enumIIFE","Object","assign","INIT","annotateAsPure","toReplace","isExportDeclaration","replaceWith","expressionStatement","assignmentExpression","scope","registerDeclaration","variableDeclaration","variableDeclarator","set","getBindingIdentifier","Error","getData","setData","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","enumValues","x","translateEnumValues","assignments","map","memberName","memberValue","isSyntacticallyString","ENUM","NAME","VALUE","ASSIGNMENTS","expr","skipTransparentExprWrapperNodes","left","right","operator","ReferencedIdentifier","state","has","hasOwnBinding","memberExpression","skip","enumSelfReferenceVisitor","_ENUMS$get","bindingIdentifier","get","Map","constValue","lastName","memberPath","member","isIdentifier","value","initializerPath","initializer","computeConstantValue","undefined","assert","Infinity","Number","isNaN","identifier","String","unaryExpression","valueToNode","isReferencedIdentifier","traverse","numericLiteral","buildCodeFrameError","lastRef","stringLiteral","binaryExpression","prevMembers","Set","evaluate","evaluateRef","evalUnaryExpression","evalBinaryExpression","quasis","length","cooked","paths","str","i","isMemberExpression","obj","object","prop","property","computed","isStringLiteral","includes","add","resolve","Math","pow"],"sources":["../src/enum.ts"],"sourcesContent":["import { template, types as t, type NodePath } from \"@babel/core\";\nimport assert from \"assert\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport { skipTransparentExprWrapperNodes } from \"@babel/helper-skip-transparent-expression-wrappers\";\n\ntype t = typeof t;\n\nconst ENUMS = new WeakMap<t.Identifier, PreviousEnumMembers>();\n\nconst buildEnumWrapper = template.expression(\n  `\n    (function (ID) {\n      ASSIGNMENTS;\n      return ID;\n    })(INIT)\n  `,\n);\n\nexport default function transpileEnum(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n) {\n  const { node, parentPath } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const { fill, data, isPure } = enumFill(path, t, node.id);\n\n  switch (parentPath.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\": {\n      // todo: Consider exclude program with import/export\n      // && !path.parent.body.some(n => t.isImportDeclaration(n) || t.isExportDeclaration(n));\n      const isGlobal = t.isProgram(path.parent);\n      const isSeen = seen(parentPath);\n\n      let init: t.Expression = t.objectExpression([]);\n      if (isSeen || isGlobal) {\n        init = t.logicalExpression(\"||\", t.cloneNode(fill.ID), init);\n      }\n      const enumIIFE = buildEnumWrapper({ ...fill, INIT: init });\n      if (isPure) annotateAsPure(enumIIFE);\n\n      if (isSeen) {\n        const toReplace = parentPath.isExportDeclaration() ? parentPath : path;\n        toReplace.replaceWith(\n          t.expressionStatement(\n            t.assignmentExpression(\"=\", t.cloneNode(node.id), enumIIFE),\n          ),\n        );\n      } else {\n        path.scope.registerDeclaration(\n          path.replaceWith(\n            t.variableDeclaration(isGlobal ? \"var\" : \"let\", [\n              t.variableDeclarator(node.id, enumIIFE),\n            ]),\n          )[0],\n        );\n      }\n      ENUMS.set(path.scope.getBindingIdentifier(name), data);\n      break;\n    }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath: NodePath<t.Node>): boolean {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nconst buildStringAssignment = template(`\n  ENUM[\"NAME\"] = VALUE;\n`);\n\nconst buildNumericAssignment = template(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString: boolean, options: Record<string, unknown>) =>\n  (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\n/**\n * Generates the statement that fills in the variable declared by the enum.\n * `(function (E) { ... assignments ... })(E || (E = {}));`\n */\nfunction enumFill(path: NodePath<t.TSEnumDeclaration>, t: t, id: t.Identifier) {\n  const { enumValues: x, data, isPure } = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) =>\n    buildEnumMember(isSyntacticallyString(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue,\n    }),\n  );\n\n  return {\n    fill: {\n      ID: t.cloneNode(id),\n      ASSIGNMENTS: assignments,\n    },\n    data,\n    isPure,\n  };\n}\n\nexport function isSyntacticallyString(expr: t.Expression): boolean {\n  // @ts-ignore(Babel 7 vs Babel 8) Type 'Expression | Super' is not assignable to type 'Expression' in Babel 8\n  expr = skipTransparentExprWrapperNodes(expr);\n  switch (expr.type) {\n    case \"BinaryExpression\": {\n      const left = expr.left;\n      const right = expr.right;\n      return (\n        expr.operator === \"+\" &&\n        (isSyntacticallyString(left as t.Expression) ||\n          isSyntacticallyString(right))\n      );\n    }\n    case \"TemplateLiteral\":\n    case \"StringLiteral\":\n      return true;\n  }\n  return false;\n}\n\n/**\n * Maps the name of an enum member to its value.\n * We keep track of the previous enum members so you can write code like:\n *   enum E {\n *     X = 1 << 0,\n *     Y = 1 << 1,\n *     Z = X | Y,\n *   }\n */\ntype PreviousEnumMembers = Map<string, number | string>;\n\ntype EnumSelfReferenceVisitorState = {\n  seen: PreviousEnumMembers;\n  path: NodePath<t.TSEnumDeclaration>;\n  t: t;\n};\n\nfunction ReferencedIdentifier(\n  expr: NodePath<t.Identifier>,\n  state: EnumSelfReferenceVisitorState,\n) {\n  const { seen, path, t } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(\n      t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)),\n    );\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier,\n};\n\nexport function translateEnumValues(path: NodePath<t.TSEnumDeclaration>, t: t) {\n  const bindingIdentifier = path.scope.getBindingIdentifier(path.node.id.name);\n  const seen: PreviousEnumMembers = ENUMS.get(bindingIdentifier) ?? new Map();\n\n  // Start at -1 so the first enum member is its increment, 0.\n  let constValue: number | string | undefined = -1;\n  let lastName: string;\n  let isPure = true;\n\n  const enumValues: Array<[name: string, value: t.Expression]> = path\n    .get(\"members\")\n    .map(memberPath => {\n      const member = memberPath.node;\n      const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n      const initializerPath = memberPath.get(\"initializer\");\n      const initializer = member.initializer;\n      let value: t.Expression;\n      if (initializer) {\n        constValue = computeConstantValue(initializerPath, seen);\n        if (constValue !== undefined) {\n          seen.set(name, constValue);\n          assert(\n            typeof constValue === \"number\" || typeof constValue === \"string\",\n          );\n          // We do not use `t.valueToNode` because `Infinity`/`NaN` might refer\n          // to a local variable. Even 1/0\n          // Revisit once https://github.com/microsoft/TypeScript/issues/55091\n          // is fixed. Note: we will have to distinguish between actual\n          // infinities and reference  to non-infinite variables names Infinity.\n          if (constValue === Infinity || Number.isNaN(constValue)) {\n            value = t.identifier(String(constValue));\n          } else if (constValue === -Infinity) {\n            value = t.unaryExpression(\"-\", t.identifier(\"Infinity\"));\n          } else {\n            value = t.valueToNode(constValue);\n          }\n        } else {\n          isPure &&= initializerPath.isPure();\n\n          if (initializerPath.isReferencedIdentifier()) {\n            ReferencedIdentifier(initializerPath, {\n              t,\n              seen,\n        